<!DOCTYPE html>

<head>
	<meta charset="utf-8"/>
	<title>Шарнирен</title>

	<script src="webgl-fmi.js"></script>
	<script src="shaders.js"></script>
	<script src="shaders-phong.js"></script>
	<script src="../../node_modules/gl-matrix/gl-matrix-min.js"></script>
	
	<script>

		var vec3 = glMatrix.vec3;
		var vec4 = glMatrix.vec4;
		var mat4 = glMatrix.mat4;

		Composite = function(center, initialObjects = []) {
			this.center = center;
			this.size = [1,1,1];
			this.offset = undefined;
			this.rot = undefined;
			this.objects = initialObjects;
		}

		Composite.prototype.add = function (object) {
			this.objects.push(object);
		}

		Composite.prototype.draw = function()
		{
			pushMatrix();
			translate(this.center);
			if (this.rot) {
				if (this.rot[0]) zRotate(this.rot[0]);	// хоризонтален ъгъл
				if (this.rot[1]) xRotate(this.rot[1]);	// вертикален ъгъл
				if (this.rot[2]) zRotate(this.rot[2]);	// осев ъгъл
			}
			scale(this.size);
			if (this.offset) translate(this.offset); // и отместването

			for (let i = 0; i < this.objects.length; i++) {
				this.objects[i].draw();
			}

			popMatrix();
		}

		function unproject(vec, view, projection, x, y, width, height) {

			var dest = vec3.create(); // The result.
			var m = mat4.create(); // The view * projection matrix.
			var im = mat4.create(); // The inverted view * projection matrix.
			var v = vec4.create(); // The vector.
			var tv = vec4.create(); // The transformed vector.

			// Apply viewport transform.
			v[0] = (vec[0] - x) * 2.0 / width - 1.0;
			v[1] = (vec[1] - y) * 2.0 / height - 1.0;
			v[2] = vec[2];
			v[3] = 1.0;

			// Build inverted view * projection matrix.
			mat4.multiply(m, projection, view);
			if(!mat4.invert(im, m)) { return null; }

			vec4.transformMat4(tv, v, im);
			if(v[3] === 0.0) { return null; }

			dest[0] = tv[0] / tv[3];
			dest[1] = tv[1] / tv[3];
			dest[2] = tv[2] / tv[3];

			return dest;

		}

		/*

        var viewmatrix, projectionmatrix;
        var x, y, width, height;

        var origin = unproject(vec3.fromvalues(x, height - y, 0), viewmatrix, projectionmatrix, 0, 0, width, height);
        var target = unproject(vec3.fromvalues(x, height - y, 1), viewmatrix, projectionmatrix, 0, 0, width, height);
        var direction = vec3.normalize(vec3.create(), vec3.sub(vec3.create(), target, origin));

        */

		function start( )
		{
			var	canvas = document.getElementById("picasso");
			canvas.addEventListener('webglcontextlost',function(event){event.preventDefault();},false);
			canvas.addEventListener('webglcontextrestored',function(){init();},false);

			init();
			drawFrame();
		}

		var mousePos={x:0,y:0};

		function init()
		{
			gl = getContext("picasso");
			glprog = getProgram(vShader,fShader);
			getVariables();
			gl.canvas.addEventListener('mousemove', evt => {
				function getMousePos() {
					var rect = gl.canvas.getBoundingClientRect();
					return {
						x: evt.clientX - rect.left,
						y: evt.clientY - rect.top
					};
				}
				mousePos = getMousePos();
			})

			gl.enable(gl.DEPTH_TEST);
			gl.clearColor(1,1,1,1);

			identity();
			projmat = perspective(30,gl.canvas.width/gl.canvas.height,1,40000);
			gl.uniform1i(uUseNormalMatrix,false);

			gl.uniform3f(uAmbientColor,0.3,0.3,0.3);
			gl.uniform3f(uDiffuseColor,1,1,1);
			gl.uniform3f(uLightDir,0,0,-1);


			spheres = []
			for (let i = 0; i < 16; i++) {
				const x = random(-10, 10);
				const y = random(-10, 10);
				const z = random(-10, 10);
				spheres.push(new Sphere([x,y,z], 2))
			}

			let gray = [0.7,0.7,0.7];
			// платформа
			{
				let cyl = new Cylinder([0,0,0], 15, 3);
				cyl.color = gray;
				let cone = new Cone([0,0,3], 15, 3);
				cone.color = gray;
                platform = new Composite([0,0,0], [cyl, cone]);
			}

			//робот
			{
			    mainPilar = new Composite([0,0,0]);
			    mainPilar.rot = [0,0,0]
				{
					let cyl = new Cylinder([0,0,0], 2, 18);
					cyl.color = gray;
					mainPilar.add(cyl);

					let cube = new Cuboid([0,0,18], [6,6,3]);
					cube.color = [0.59, 0.55, 0.40];
					mainPilar.add(cube);
				}

				bluePart = new Composite([0,0,21])
                bluePart.rot = [0,0,90]
                mainPilar.add(bluePart);
				{
				    let cyl = new Cylinder([0,0,0], 3, 8);
				    cyl.color = gray;
				    cyl.offset = [0,0,-0.5];
				    cyl.rot = [0, 90, 0];
				    bluePart.add(cyl);

					let cap1 = new Cylinder([0,4.5,0], 3, 1);
					cap1.color = [0.10, 0.10, 0.60];
					cap1.offset = [0,0,-0.5];
					cap1.rot = [0, 90, 0];
					bluePart.add(cap1);

					let cap2 = new Cylinder([0,-4.5,0], 3, 1);
					cap2.color = [0.10, 0.10, 0.60];
					cap2.offset = [0,0,-0.5];
					cap2.rot = [0, 90, 0];
					bluePart.add(cap2);

					let ext1 = new Cuboid([0,4.5,0], [6, 12, 1]);
					ext1.color = [0.10, 0.10, 0.60];
					ext1.offset = [0,-0.5,0];
					ext1.rot = [0, 90, 0];
					bluePart.add(ext1);

					let ext2 = new Cuboid([0,-4.5,0], [6, 12, 1]);
					ext2.color = [0.10, 0.10, 0.60];
					ext2.offset = [0,-0.5,0];
					ext2.rot = [0, 90, 0];
					bluePart.add(ext2);
				}

				upperCyl = new Composite([0,0,12])
				upperCyl.rot = [90,0,90]
				bluePart.add(upperCyl);
				{
					let cyl = new Cylinder([0,0,0], 3, 8);
					cyl.color = gray;
					cyl.offset = [0,0,-0.5];
					cyl.rot = [0, 90, 0];
					upperCyl.add(cyl);

					let cap1 = new Cylinder([0,4.5,0], 3, 1);
					cap1.color = [0.10, 0.10, 0.60];
					cap1.offset = [0,0,-0.5];
					cap1.rot = [0, 90, 0];
					upperCyl.add(cap1);

					let cap2 = new Cylinder([0,-4.5,0], 3, 1);
					cap2.color = [0.10, 0.10, 0.60];
					cap2.offset = [0,0,-0.5];
					cap2.rot = [0, 90, 0];
					upperCyl.add(cap2);

					let cube = new Cuboid([0,0,3.5], [6,6,3]);
					cube.color = [0.59, 0.55, 0.40];
					upperCyl.add(cube);
				}

				let pos = 0;
				colorPilar = new Composite([0,0,5])
				colorPilar.rot = [0,0,0];
				upperCyl.add(colorPilar);
				{
					let h = 3;
					let cyl1 = new Cylinder([0,0,pos], 2, h);
					cyl1.color = gray;
					colorPilar.add(cyl1);
					pos += h;

					h = 1;
					let cyl2 = new Cylinder([0,0,pos], 2, h);
					cyl2.color = [0.48, 0.03, 0.03];
					colorPilar.add(cyl2);
					pos += h;

					h = 5;
					let cyl3 = new Cylinder([0,0,pos], 2, h);
					cyl3.color = [0.05, 0.81, 0.09];
					colorPilar.add(cyl3);
					pos += h;

					h = 1;
					let cyl4 = new Cylinder([0,0,pos], 2, h);
					cyl4.color = [0.48, 0.03, 0.03];
					colorPilar.add(cyl4);
					pos += h;

					h = 1.5;
					let cyl5 = new Cylinder([0,0,pos], 2, h);
					cyl5.color = gray;
					colorPilar.add(cyl5);
					pos += h;

					h = 1;
					let cyl6 = new Cylinder([0,0,pos], 2, h);
					cyl6.color = [0.73, 0.69, 0.21];
					colorPilar.add(cyl6);
					pos += h;

					h = 1;
					let cyl7 = new Cylinder([0,0,pos], 2, h);
					cyl7.color = [0.05, 0.81, 0.09];
					colorPilar.add(cyl7);
					pos += h;
				}

				endHandle = new Composite([0,0,pos+2.5])
				endHandle.rot = [0,0,90];
				colorPilar.add(endHandle);
				{
					let cyl = new Cylinder([0,0,0], 3, 8);
					cyl.color = gray;
					cyl.offset = [0,0,-0.5];
					cyl.rot = [0, 90, 0];
					endHandle.add(cyl);

					let cap1 = new Cylinder([0,4.5,0], 3, 1);
					cap1.color = gray;
					cap1.offset = [0,0,-0.5];
					cap1.rot = [0, 90, 0];
					endHandle.add(cap1);

					let cap2 = new Cylinder([0,-4.5,0], 3, 1);
					cap2.color = gray;
					cap2.offset = [0,0,-0.5];
					cap2.rot = [0, 90, 0];
					endHandle.add(cap2);

					let ext1 = new Cuboid([0,4.5,0], [6, 12, 1]);
					ext1.color = gray;
					ext1.offset = [0,-0.5,0];
					ext1.rot = [0, 90, 0];
					endHandle.add(ext1);

					let ext2 = new Cuboid([0,-4.5,0], [6, 12, 1]);
					ext2.color = gray;
					ext2.offset = [0,-0.5,0];
					ext2.rot = [0, 90, 0];
					endHandle.add(ext2);

					let top = new Cuboid([0,0,12], [6, 10, 1]);
					top.color = gray;
					endHandle.add(top);
				}

				endPart = new Composite([0,0,12])
				endPart.rot = [0,0,0];
				endHandle.add(endPart);
				{
					let cyl1 = new Cylinder([0,0,0], 2, 8);
					cyl1.color = gray;
					endPart.add(cyl1);

					let cyl2 = new Cylinder([0,0,8], 2, 1);
					cyl2.color = [0.48, 0.03, 0.03];
					endPart.add(cyl2);

					let cross1 = new Cuboid([0,0,9], [3,1,1]);
					cross1.offset = [0,0,0.5];
					cross1.color = [0.89, 0.89, 0.00];
					endPart.add(cross1);

					let cross2 = new Cuboid([0,0,9], [3,1,1]);
					cross2.offset = [0,0,0.5];
					cross2.color = [0.89, 0.89, 0.00];
					cross2.rot = [0,0,90]
					endPart.add(cross2);
				}
			}
		}

		var time = now();
		var timeStart = now();
		function now() { return (new Date()).getTime()/1000; }

		function l(a, x) {
			console.log(a +": "+ x);
		}

		function intersectSphere( sphere, rFrom , rTo) {
		    const sCenter = vec3.fromValues(...sphere.center);
			const oc = vec3.sub(vec3.create(), rFrom, sCenter );
			const rDir = vec3.normalize(vec3.create(), vec3.sub(vec3.create(), rTo, rFrom));
			l("Center", sCenter);
			l("oc", oc);
			l("rDir", rDir);

			const a = vec3.dot(rDir, rDir)
			const b = 2 * vec3.dot(oc, rDir)
			const c = vec3.dot(oc, oc) - sphere.size * sphere.size;
			l("a", a);
			l("b", b);
			l("c", c);

			const discriminant = b * b - 4 * a * c;
			if (discriminant < 0) {
				return false;
			}
			let t = (-b - Math.sqrt(discriminant)) / (2*a);
			if (!(t >= 0 || t <= 1)) {
				t = (-b + Math.sqrt(discriminant)) / (2*a);
				if (!(t >= 0 || t <= 1)) {
					return false;
				}
			}

			const orig = vec3.scale(vec3.create(), rFrom, (1-t));
			const dest = vec3.scale(vec3.create(), rTo, t);
			return vec3.add(vec3.create(), orig, dest);
		}

		function drawFrame()
		{
			time = now();
			gl.clear(gl.COLOR_BUFFER_BIT+gl.DEPTH_BUFFER_BIT);

			let radius = 50;
			var rotation = false;
			if (rotation) {
				lookAt([radius*cos(time/5),radius*sin(time/5),30],[0,0,22],[0,0,1]);
			} else {
				lookAt([radius/1.2,radius/1.2,0],[0,0,0],[0,0,1]);
			}


			var viewmatrix, projectionmatrix;
			var x=mousePos.x, y=mousePos.y, width=gl.canvas.width, height=gl.canvas.height;

			let viewmat =  Array.prototype.slice.call(glvmat);
			viewmatrix = mat4.fromValues(...viewmat);

			var perspmat =  Array.prototype.slice.call(projmat);
			projectionmatrix = mat4.fromValues(...perspmat)

			var point = unproject(vec3.fromValues(x, height - y, 0), viewmatrix, projectionmatrix, 0, 0, width, height);
			var target = unproject(vec3.fromValues(x, height - y, 1), viewmatrix, projectionmatrix, 0, 0, width, height);

			// var s = new Sphere(Array.prototype.slice.call(point), 1);
			// s.draw();

			for (let i = 0; i < spheres.length; i++) {
			    console.log(intersectSphere(spheres[i], point, target));
				if (intersectSphere(spheres[i], point, target)) {
					spheres[i].color = [255, 0, 0];
				} else {
					spheres[i].color = [0, 0, 255];
				}
				spheres[i].draw();
			}


			mainPilar.rot[2] = time*100;
			bluePart.rot[1] = 60*sin(time);
			upperCyl.rot[1] = 60*cos(time+150);
			colorPilar.rot[2] = time*100;
			endHandle.rot[1] = 90*sin(time);
			endPart.rot[2] = time*500;

			// platform.draw();
			// mainPilar.draw();

			requestAnimationFrame(drawFrame);
		}
	</script>	
</head>

<body onload="start()">
	<h2>Шарнирен Робот</h2>

	<noscript>
		Искаме JavaScript, но няма!
	</noscript>
	
	<canvas id="picasso" width="600" height="400" >
		Искаме canvas, но няма!
	</canvas>
</body>
